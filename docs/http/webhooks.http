###
# @name Unpublish BlogPage (Contentful)
POST {{host}}/webhook/contentful
Content-Type: application/json
X-Contentful-Topic: ContentManagement.Entry.unpublish
x-contentful-secret: {{contentfulSecret}}
X-Contentful-Webhook-Name: blogpage_publishing
X-Contentful-CRN: crn:contentful:::content:spaces/0c7qlubj8id5/environments/master/entries/47oxuTsSSzRFR0KtU4mZS5
x-contentful-timestamp: 1730836572106

{"sys":{"type":"DeletedEntry","id":"47oxuTsSSzRFR0KtU4mZS5","space":{"sys":{"type":"Link","linkType":"Space","id":"0c7qlubj8id5"}},"environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":7,"createdAt":"2024-11-05T19:56:11.992Z","updatedAt":"2024-11-05T19:56:11.992Z","deletedAt":"2024-11-05T19:56:11.992Z","contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPage"}},"deletedBy":{"sys":{"type":"Link","linkType":"User","id":"6ag7jJYtJBgxYIH4P8YBR3"}}}}

###
# @name Publish BlogPage (Contentful)
POST {{host}}/webhook/contentful
Content-Type: application/json
X-Contentful-Topic: ContentManagement.Entry.publish
x-contentful-secret: {{contentfulSecret}}
X-Contentful-Webhook-Name: blogpage_publishing
X-Contentful-CRN: crn:contentful:::content:spaces/0c7qlubj8id5/environments/master/entries/47oxuTsSSzRFR0KtU4mZS5
x-contentful-timestamp: 1730836572106

{"metadata":{"tags":[],"concepts":[]},"fields":{"title":{"fr":"Discover Bitcoin #1 : Création d'une adresse bitcoin"},"slug":{"fr":"discover-bitcoin-1-creation-dune-adresse-bitcoin"},"image":{"fr":{"sys":{"type":"Link","linkType":"Asset","id":"1NjA2igyhfieyAHlmTWOSf"}}},"description":{"fr":"L'objectif de cette suite d'article est de mieux comprendre les aspects techniques de la blockchain en s'appuyant sur la blockchain la plus populaire : Bitcoin. Dans cette première partie, voyons comment créer une adresse valide et utilisable sur la blockchain Bitcoin."},"content":{"fr":"\n> Les sources du projet sont disponibles sur GitHub : [adrien-chinour/discover-blockchain](https://github.com/adrien-chinour/discover-blockchain)\n\n## Introduction\n\nUne adresse en cryptomonnaie correspond à un RIB. Cela vous permet d'identifier le portefeuille (le compte). Vous pouvez donc la partager a n'importe qui pour recevoir de l'argent.\n\n> Transfer/receive transactions of Bitcoins (Cryptocurrency, BTC) can be performed via address like the work with e-mail messages. (https://bitcoinwiki.org/wiki/address#Purpose_and_opportunities)\n\nIl y a différents types d'adresses, comme présenté dans cet article : [Bitcoin address types compared: P2PKH, P2SH, P2WPKH, and more](https://unchained.com/blog/bitcoin-address-types-compared/).\n\nLes types les plus utilisés sont :\n- **P2PKH** : Pay-To-Public-Key-Hash (43%)\n- **P2WPKH** : Pay-to-Witness-Public-Key-Hash (20%)\n- **P2SH** : Pay-To-Script-Hash (24%)\n- **P2WSH** : Pay-to-Witness-Script-Hash (4%)\n\nVoyons d'abord le format, encore aujourd'hui, le plus commun : P2PKH ; même s'il tend à être remplacé par son évolution P2WPKH.\n\n## Génération d'une adresse P2PKH\n\nCe type d'adresse est le plus commun est fonctionne sur le mécanisme de clé publique et clé privée. La clé publique est partagée et permet de valider une transaction alors que notre clé privée permet de signer une transaction.\n\nOn peut y lire qu'une adresse utilise ECDSA comme algorithme de génération de notre couple clé publique et clé privée :\n\n> Bitcoin uses the Elliptic Curve Digital Signature Algorithm (ECDSA) with the secp256k1 curve; secp256k1 private keys are 256 bits of random data. https://developer.bitcoin.org/devguide/transactions.html\n\nDans les grandes lignes parce que l'objectif n'est pas de rentrer dans le détail de ECDSA, on va fournir en entrée un entier aléatoire, nommé _k_, dans l'intervalle _[1, n - 1 ]_ avec _n_ égal à _2^256_ pour _secp256k1_.\n\nL'algorithme va ensuite nous donner les coordonnées x et y de notre point _k x G_ sur la courbe elliptique. G étant le point initial de la courbe. (x,y) correspond à notre clé publique. Et la complexité de cet algorithme réside dans la difficulté à obtenir k sachant (x,y).\n\nPassons au code, on va utiliser les fonctions crypto déjà fournies en go pour calculer notre clé privée et notre clé publique :\n\n> Ce qu'il faut savoir et qui est très important, c'est que le seed que l'on va fournir contient le seul secret qui importe dans notre clé. La clé privée générée à partir de celui-ci sera toujours identique et par conséquent la clé publique aussi.\n\nPassons au code, ici, on va utiliser les fonctions crypto déjà fournies en go pour calculer notre clé privée et notre clé publique :\n\n```go\nfunc main() {\n\t// Generate a private key based on secp256k1 ellipsis curve\n\tprivateKey, err := ecdsa.GenerateKey(btcec.S256(), rand.Reader)\n\tif err != nil {\n\t\tfmt.Println(\"Cannot generate private key.\", err)\n\t}\n\n\t// Display private key as hexadecimal string\n\tfmt.Printf(\"Private Key: %s\\n\", hex.EncodeToString(privateKey.D.Bytes()))\n\n\t// Display public key as hexadecimal string\n\tpublicKey := append(privateKey.X.Bytes(), privateKey.Y.Bytes()...)\n\tfmt.Printf(\"Public Key: %s\\n\", hex.EncodeToString(publicKey))\n}\n```\n\nMais on n'a pas encore fini parce que notre clé publique ne correspond pas à une adresse Bitcoin. Pour ça il nous manque quelques étapes :\n\n![PubKeyToAddr](//images.ctfassets.net/0c7qlubj8id5/38rr2hUJrkV4Ivx0uhdSVL/b3d0eb2f0b96fb66165f22ee154a73ac/image.png)\n\nL'avantage de cette opération est de sécuriser encore plus notre clé publique en fournissant un hash de celle-ci et surtout d'économiser de la place dans la blockchain en réduisant le nombre de bit par adresse. https://privacypros.io/btc-faq/how-many-btc-addresses\n\n```go\nfunc hash(input []byte, hash crypto.Hash) []byte {\n\thasher := hash.New()\n\thasher.Write(input)\n\n\treturn hasher.Sum(nil)\n}\n\nfunc publicKeyToAddress(publicKey ecdsa.PublicKey) (string, error) {\n\tpublicKeyBytes := append(publicKey.X.Bytes(), publicKey.Y.Bytes()...)\n\n\tnetwork := byte(0x00)\n\tfingerprint := hash(hash(publicKeyBytes, crypto.SHA256), crypto.RIPEMD160)\n\n\taddress := append([]byte{network}, fingerprint...)\n\tchecksum := hash(hash(fingerprint, crypto.SHA256), crypto.SHA256)[:4]\n\n\treturn base58.Encode(append(address, checksum...)), nil\n}\n```\n\n`0x00` correspond a notre type d'adresse sur le réseau principal : MainNet.\nIl existe un réseau de test : TestNet. Dans le TestNet il faudra utiliser `0x6f`.\n\n> Le détail de l'algorithme est détaillé dans cette documentation : [https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses](https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses)\n\nEt pour valider que notre adresse est utilisable et vérifier l'état du portefeuille on peut utiliser ce site : [https://www.blockchain.com/explorer](https://www.blockchain.com/explorer).\n\nPassons a l'évolution de cette première génération d'adresse : P2WPKH.\n\n## Génération d'une adresse P2WPKH\n\nTout d'abord, il faut comprendre pourquoi ce nouveau terme : \"Witness\".\n\n> SegWit (abréviation de Segregated Witness) est une mise à niveau rétrocompatible du protocole Bitcoin qui modifie en profondeur la structure des transactions en déplaçant les données de signature (le témoin ou witness) dans une base de données séparée (segregated). https://cryptoast.fr/segwit-bitcoin-explication-definition/\n\nIl s'agit d'un changement dans le protocole qui permet d'accélérer le débit des transactions en intégrant un plus grand nombre de transactions au sein d'un même bloc. Et tout ça, simplement en réduisant la taille d'une transaction.\n\nAu niveau de notre adresse, cela ne change pas énormément. En utilisant la documentation suivante https://en.bitcoin.it/wiki/Bech32, on peut écrire le code suivant :\n\n```go\nfunc P2WPKH() BitcoinAddress {\n   privateKey, _ := ecdsa.GenerateKey(btcec.S256(), rand.Reader)\n\n   // Compressed public key based on Elliptic-Curve-Point-to-Octet-String Conversion (https://www.secg.org/sec1-v2.pdf)\n   publicKey := elliptic.MarshalCompressed(privateKey.Curve, privateKey.PublicKey.X, privateKey.PublicKey.Y)\n\n   // Witness version, current is 0\n   version := byte(0x00)\n\n   // Hash public key with SHA256 then RIPEMD160\n   hashedKey := hash(hash(publicKey, crypto.SHA256), crypto.RIPEMD160) \n\n   // 8-bit unsigned integer to 5-bit unsigned integers\n   fingerprint, _ := bech32.ConvertBits(hashedKey, 8, 5, true)\n\n   // Encode to bech32 format with network (bc = main network) and checksum calculated\n   address, _ := bech32.Encode(\"bc\", append([]byte{version}, fingerprint...))\n\n   return BitcoinAddress{address: address, privateKey: hex.EncodeToString(privateKey.D.Bytes())}\n}\n```\n\nPas beaucoup de changement, simplement des améliorations techniques par rapport à notre version P2PKH.\n\nMaintenant que l'on a vu le fonctionnement d'une adresse par clé publique, voyons les différences avec les adresses par script.\n\n## Génération d'une adresse P2SH\n\nLes deux formats P2SH et son évolution P2WSH repose sur l'exécution d'un script qui renverra True ou False pour valider ou non une transaction.\n\nLe script permet plus de flexibilité dans la signature d'une transaction. On retrouve plusieurs usages comme :\n1. **Les transactions multi-signature** : plusieurs clés publiques doivent être utilisées pour autoriser une transaction\n2. **Le dépôt fiduciaire** : service dans lequel une tierce partie, appelée *escrow*, retient temporairement les fonds pendant que les parties impliquées dans la transaction satisfont aux conditions convenues.\n3. **Transactions Atomic Swaps** : permettent l'échange atomique de cryptomonnaies entre deux parties sans nécessiter de tiers de confiance. [_Qu'est-ce qu'un Atomic Swap ?_](https://cryptoast.fr/quest-ce-quun-atomic-swap/)\n\n> Un article en français qui parle des différents usages : [Les smart contracts avec Bitcoin](https://cryptoast.fr/smart-contracts-bitcoin-exemples/)\n\nPour un exemple assez simple, je vais générer une adresse qui nécessite la signature de 2 clés publiques. Pour ça je me base sur la documentation présente ici : https://en.bitcoin.it/wiki/Script et qui me donne les instructions que je peux définir dans mon script :\n\n```\nOP_2 <publicKey1> <publicKey2> OP_2 OP_CHECKMULTISIG\n```\n\nOn peut générer notre adresse avec le code suivant :\n\n```go\nfunc AddressPubKey() []byte {\n\tprivateKey, _ := ecdsa.GenerateKey(btcec.S256(), rand.Reader)\n\treturn elliptic.MarshalCompressed(privateKey.Curve, privateKey.PublicKey.X, privateKey.PublicKey.Y)\n}\n\n// MultiSignAddress demonstrate P2SH address\nfunc MultiSignAddress() {\n\t// In this exemple, we use 2 initial P2PK addresses\n\taddress1, _ := btcutil.NewAddressPubKey(AddressPubKey(), &chaincfg.MainNetParams)\n\taddress2, _ := btcutil.NewAddressPubKey(AddressPubKey(), &chaincfg.MainNetParams)\n\tpubKeys := []*btcutil.AddressPubKey{address1, address2}\n\n\t// Create MultiSign Script\n\t// OP_2 <publicKey1> <publicKey2> OP_2 OP_CHECKMULTISIG\n\tscript, _ := txscript.MultiSigScript(pubKeys, 2)\n\n\t// 0x05 for MainNet, Oxc4 for TestNet\n\tnetwork := byte(0x05)\n\n\thashedScript := hash(hash(script, crypto.SHA256), crypto.RIPEMD160)\n\n\taddress := append([]byte{network}, hashedScript...)\n\tchecksum := hash(hash(address, crypto.SHA256), crypto.SHA256)[:4]\n\n\tprint(base58.Encode(append(address, checksum...)))\n```\n\nLa méthodologie est assez proche de ce que l'on a pour P2PKH, à la différence qu'on ne part pas d'une clé mais d'un script. Pour générer une adresse P2WSH, on applique bech32 sur notre script.\n\n## En conclusion\n\nOn a vu les principaux types d'adresses disponibles sur la blockchain Bitcoin. Rendez-vous dans la deuxième partie pour voir comment utiliser notre adresse. Et en bonus voici un résumé graphique de cette génération d'adresse Bitcoin.\n\n![Address map](//images.ctfassets.net/0c7qlubj8id5/37AUW8wPaX6lIRPt9lXDeM/155342abbb2e01140679626ddf2f431a/Address_map.jpg)\n> Source : https://en.bitcoin.it/wiki/File:Address_map.jpg"},"categories":{"fr":[{"sys":{"type":"Link","linkType":"Entry","id":"7i91dfFT9WkzSKBVFkrYZd"}}]}},"sys":{"type":"Entry","id":"47oxuTsSSzRFR0KtU4mZS5","space":{"sys":{"type":"Link","linkType":"Space","id":"0c7qlubj8id5"}},"environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPage"}},"createdBy":{"sys":{"type":"Link","linkType":"User","id":"6ag7jJYtJBgxYIH4P8YBR3"}},"updatedBy":{"sys":{"type":"Link","linkType":"User","id":"6ag7jJYtJBgxYIH4P8YBR3"}},"revision":4,"createdAt":"2024-04-07T08:56:25.883Z","updatedAt":"2024-11-05T16:46:51.356Z"}}

